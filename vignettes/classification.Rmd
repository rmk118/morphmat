---
title: "Classification methods"
output: rmarkdown::html_vignette
format: 
    code-overflow: wrap
    toc: true
    toc-depth: 3
    df-print: kable
    code-fold: true
vignette: >
  %\VignetteIndexEntry{Classification methods}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
link-external-newwindow: true 
number-sections: true
link-citations: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
#| message: FALSE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE

library(morphmat)
library(dplyr)
library(ggplot2)

knitr::opts_chunk$set(message = FALSE)
```

```{r}
#| label: setup-2
#| echo: false

mytheme <- theme_classic() + # define custom theme for ggplots
  theme(
    axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0)),
    axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)),
    text = element_text(size = 13))
```

This vignette describes methods that first classify individual data points as mature or immature, enabling the use of logistic regression to find SM50 as would be done with a physiological metric of maturity. This vignette will be useful for referring readers to more complex options available in packages like `mclust` that are not available within `morphmat`.

We will start by simulating a data set with a known SM50 value of 75 mm to demonstrate the use (and limitations) of broken-stick methods.

```{r}
#| label: generate-crabs

set.seed(123) # set seed for reproducibility

fc <- fake_crustaceans(
  error_scale = 17,
  slope = 9,
  L50 = 75,
  n = 800,
  allo_params = c(0.9, 0.25, 1.05, 0.2),
  x_mean = 85
)
```

```{r}
#| echo: false

ggplot() +
  geom_point(data = fc, aes(x, y), alpha = 0.4) +
  labs(x = "CW (mm)", y = "CH (mm)", ) +
  mytheme
```

# Clustering methods

Endless clustering methods have been implemented in existing R packages. I will be using simulation testing to evaluate the relative performance of common clustering methods when used to separate immature and mature crustaceans based on morphometric data. Functions included in the simulation testing will include `hclust()` and `kmeans()` from the base R `stats` package; `factoextra::hkmeans()`; `cluster::PAM()`; `mclust::Mclust()`; and `dbscan()`, `hdbscan()`, and `OPTICS()` from the `dbscan` package.

The Somerton method is a clustering method widely used for estimating size at maturity based on the allometric growth of crustacean body parts, originally written in FORTRAN [@somerton1980a]. `morphmat` will contain code to implement the Somerton method in R, largely following the structure of code written by Dr. Bradley Stevens.

## Somerton method

```{r}
out_df <- somerton_fun(fc, xvar = "x", yvar = "y")[[1]]
mod <- glm(data = out_df,
           pred_mat_num ~ x,
           family = binomial(link = "logit"))
unname(-coef(mod)[1] / coef(mod)[2])
```

# Other classification methods

## Inflection point discriminant method

```{r}
disc <- infl_pt(fc, "x", "y", plot = TRUE)
```

```{r}
#| label: fig-inflpt-line
#| fig-cap: "Simulated data with addition of linear discriminant function identified via the inflection point method"

ggplot() +
  geom_point(data = fc, aes(x, y), alpha = 0.4) +
  labs(x = "CW (mm)", y = "CH (mm)", ) +
  mytheme + geom_abline(slope = disc, color = "red", linewidth = 1.3)
```

The line can then be used to classify each point as immature and mature, enabling logistic regression to be applied to estimate SM50:

```{r}
fc_infl_pt <- fc %>% mutate(pred_mat = as.factor(if_else(y / x > disc, 1, 0)),
                            correct = if_else(pred_mat == mature, TRUE, FALSE))
```

```{r}

if (rlang::is_installed("patchwork")) {
  (ggplot() +
      geom_point(data = fc_infl_pt, aes(x, y, color = mature), alpha = 0.4) +
      labs(x = "CW (mm)", y = "CH (mm)", title = "True maturity") +
      mytheme) +
    (ggplot() +
        geom_point(data = fc_infl_pt, aes(x, y, color = pred_mat), alpha = 0.4) +
        labs(x = "CW (mm)", y = "CH (mm)", title = "Predicted maturity") +
        mytheme)
} else {
  ggplot() +
    geom_point(data = fc_infl_pt, aes(x, y, color = mature), alpha = 0.4) +
    labs(x = "CW (mm)", y = "CH (mm)", title = "True maturity") +
    mytheme
  
  ggplot() +
    geom_point(data = fc_infl_pt, aes(x, y, color = pred_mat), alpha = 0.4) +
    labs(x = "CW (mm)", y = "CH (mm)", title = "Predicted maturity") +
    mytheme
}
```

<!-- # Discriminant Analysis -->

<!-- Talk about drawbacks and reasons why it is unnecessary, but mention instances where it might be useful (stock assessment, applications to related species). -->

# Post-classification logistic regression

Once a method of maturity classification has been identified, many additional choices need to be made when using logistic regression to obtain an estimate of SM50, particularly if you want to obtain standard errors, confidence intervals, etc. This aspect of the analysis is the same as determining size at maturity for non-crustacean fisheries.

The most common way to do this is to fit a generalized linear model using the binomial family with a logit link, then taking the ratio of the estimated coefficients to find the SM50 value. For example, using the classifications produced by the Somerton method:

```{r}
infl_pt_mod <- glm(pred_mat ~ x,
                   family = binomial(link = "logit"),
                   data = fc_infl_pt)

# SM50 = -A/B
unname(-coef(infl_pt_mod)[1] / coef(infl_pt_mod)[2])
```

Beyond the familiar `stats::glm`, there are many packages that can be used to model the relationship between size and maturity status, allowing for the incorporation of random effects, temporal or spatial structuring, and other additional complexities. These include popular packages for fitting generalized linear mixed models (GLMMs) and generalized additive (mixed) models (GAMMs) such as `lmer`, `nlme`, `mgcv`, `glmmTMB`, and `sdmTMB`.

## Methods to obtain confidence intervals for SM50 value

1.  [confint_L.R script](https://github.com/rafamoral/L50/blob/main/confint_L.R) from Mainguy et al. [-@mainguy2024]: Delta method, Fieller method, profile-likelihood, non-parametric bootstrapping, parametric bootstrapping, Monte Carlo, Bayesian

2.  R package qra: Fieller method

3.  R package twopartm: Fieller method

4.  R package drc [@ritz2015]: Delta method, Fieller method. This package can also fit 5/4/3/2-parameter logistic, log-logistic, Weibull, etc. models, incorporate weights, robust nls fitting, constrained optimization, and other customization options. It also contains functions to simulate data

5: R package tidydelta: Delta method
